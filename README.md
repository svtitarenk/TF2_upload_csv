# Application

## Развертывание
1. Собираем контейнеры
`docker-compose -f staging-local.docker-compose.yml build`
2. Запустить контейнеры 
`docker-compose -f staging-local.docker-compose.yml up -d`
3. Авторизация
- логин: start_admin
- пароль: starter12345


## Описание приложения 

Цель приложения - определить навыки исполнителя в использовании систем git, docker и в написании автоматических тестов 
для веб-приложения построенного по принципам микро-сервисной архитектуры, сервисы которого коммутируют используя шину RabbitMQ на стороне backend и Websocket 
на стороне клиента. В приложении схематично реализована работа нескольких сервисов. Функциональность приложения простая, имя загружаемого файла 
разделяется на имя файла и расширение, далее отдельно пишутся в выделенные поля базы данных. Завершив запись обновляется и отображаются результаты на стороне клиента.

Основные компоненты

- Client: [reactjs](https://ru.reactjs.org/), [material-ui](https://material-ui.com/ru/). GUI для пользователей
- Balancer: [nginx](https://nginx.org/ru/). Отвечает за routing запросов от клиента к компонентам системы.
- Real-time notificator: [tornado](https://www.tornadoweb.org/en/stable/), [aio-pika](https://aio-pika.readthedocs.io/en/latest/). Отвечает за обновление данных на клиенте в режиме реального времени.
- API: [django](https://www.djangoproject.com/), [django rest framework](https://www.django-rest-framework.org/). Отвечает за логику приложения, а также является связующим звеном с контроллером.
- Database: [postgres](https://www.postgresql.org/). Основное хранилище данных
- AMQP: [rabbitmq](https://www.rabbitmq.com/). Единая шина коммуникации между сервисами.
- Controller: [django](https://www.djangoproject.com/), [django rest framework](https://www.django-rest-framework.org/).  Отдельный django процесс выполняющий парсинг имени файла и записи данных в БД.

Функциональность

1. Авторизация 
2. Загрузка файла на сервер
3. Проброс сообщений контроллеру используя брокер сообщений rabbitmq 
4. Парсинг имени файла на стороне контроллера. Имя и расширение файла записываются в отдельные поля БД.
5. Обновление состояние клиента в режиме real-time используя websocket

## Задание

### Backend-часть
Для тестирования бэкенда необходимо использовать модуль pytest. Обратите внимание, приложение практически полностью
уже "обёрнуто" тестами, кроме одной фикстуры admin (api.conftest), и одной функции test_user_flow (api.users.tests)
1. Исправить фикстуру admin, которая должна возвращать пользователя со статусом администратора.
2. Дополнить функцию test_user_flow которая, используя пользователя со статусом администратора, сгенерирует несколько 
случайный данных новых пользователей, создаст пользователей используя сгенерированные данные, проверит в БД кол-во созданных пользователей,
проверит возможность авторизации для каждого созданного пользователя, используя сгенерированные выше данные. Удалит всех созданных пользователей.

Подсказка. 
Более подробно необходимые данные расписаны внутри функций, которых требуется дополнить. 


### Frontend-часть
Выполнять тестирование для фронтенда необязательно, но будет большим плюсом для кандидата, если вы покажете навыки сквозного 
тестирования фронтенда, к примеру используя Puppeteer или просто Python Selenium Webdriver.


### Результат выполнения задания

Для начала выполнения задания, следует клонировать данный репозиторий в свой вновь созданный проект. По завершению выполнения задач, залить сделанные коммиты и 
выслать ссылку на ваш репозиторий.
